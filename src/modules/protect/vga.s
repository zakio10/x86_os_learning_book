;************************************************************************
;	読み込みプレーンの選択
;========================================================================
;■書式		: void vga_set_read_plane(plane);
;
;■引数
;	plane	: 読み込みプレーン
;
;■戻り値	: 無し
;************************************************************************
vga_set_read_plane:
		;---------------------------------------
		; 【スタックフレームの構築】
		;---------------------------------------
												; EBP+ 8| プレーン（インデックス）
												; ------+----------------
		push	ebp								; EBP+ 4| EIP（戻り番地）
		mov		ebp, esp						; EBP+ 0| EBP（元の値）
												; ------+----------------

		;---------------------------------------
		; 【レジスタの保存】
		;---------------------------------------
		push	eax
		push	edx

		;---------------------------------------
		; 読み込みプレーンの選択
		;---------------------------------------
		mov		ah, [ebp + 8]					; AH  = プレーンを選択（3=輝度, 2〜0=RGB）
		and		ah, 0x03						; AH &= 0x03; // 余計なビットをマスク
		mov		al, 0x04						; AL  = 読み込みプレーン選択レジスタ
		mov		dx, 0x03CE						; DX  = グラフィックス制御ポート
		out		dx, ax							; // ポート出力

		;---------------------------------------
		; 【レジスタの復帰】
		;---------------------------------------
		pop		edx
		pop		eax

		;---------------------------------------
		; 【スタックフレームの破棄】
		;---------------------------------------
		mov		esp, ebp
		pop		ebp

		ret

;************************************************************************
;	書き込みプレーンを選択
;========================================================================
;■書式		: void vga_set_write_plane(plane);
;
;■引数
;	plane	: 書き込みプレーン
;
;■戻り値	: 無し
;************************************************************************
vga_set_write_plane:
		;---------------------------------------
		; 【スタックフレームの構築】
		;---------------------------------------
												; EBP+ 8| プレーン（ビット指定）
												; ------+----------------
		push	ebp								; EBP+ 4| EIP（戻り番地）
		mov		ebp, esp						; EBP+ 0| EBP（元の値）
												; ------+----------------

		;---------------------------------------
		; 【レジスタの保存】
		;---------------------------------------
		push	eax
		push	edx

		;---------------------------------------
		; 書き込みプレーンの選択
		;---------------------------------------
		mov		ah, [ebp + 8]					; AH = 書き込みプレーンを指定(Bit:----IRGB)
		and		ah, 0x0F						; AH = 0x0F; // 余計なビットをマスク
		mov		al, 0x02						; AL = 書き込みプレーン選択
		mov		dx, 0x03C4						; DX = シーケンサ制御ポート
		out		dx, ax							; // ポート出力

		;---------------------------------------
		; 【レジスタの復帰】
		;---------------------------------------
		pop		edx
		pop		eax

		;---------------------------------------
		; 【スタックフレームの破棄】
		;---------------------------------------
		mov		esp, ebp
		pop		ebp

		ret

;************************************************************************
;	フォントの書き込み
;========================================================================
;■書式		: void vram_font_copy(font, vram, plane, color);
;
;■引数
;	font	: FONTアドレス
;	vram	: VRAMアドレス
;	plane	: 出力プレーン（１つのプレーンのみをビットで指定）
;	color	: 描画色
;
;■戻り値	: 無し
;************************************************************************
vram_font_copy:
		;---------------------------------------
		; 【スタックフレームの構築】
		;---------------------------------------
												; EBP+20| 色（背景/前景色）
												; EBP+16| プレーン（ビット指定）
												; EBP+12| VRAMアドレス
												; EBP+ 8| FONTアドレス
												; ------+----------------
		push	ebp								; EBP+ 4| EIP（戻り番地）
		mov		ebp, esp						; EBP+ 0| EBP（元の値）
												; ------+----------------

		;---------------------------------------
		; 【レジスタの保存】
		;---------------------------------------
		push	eax
		push	ebx
		push	ecx
		push	edx
		push	esi
		push	edi

		;---------------------------------------
		; 【処理の開始】
		;---------------------------------------
		mov		esi, [ebp + 8]					; ESI = フォントアドレス;
		mov		edi, [ebp +12]					; EDI = VRAMアドレス;
		movzx	eax, byte [ebp +16]				; EAX = プレーン（ビット指定）;
		movzx	ebx, word [ebp +20]				; EBX = 色;

		test	bh, al							; ZF = (背景色 & プレーン);
		setz	dh								; AH = ZF ? 0x01 : 0x00
		dec		dh								; AH--; // 0x00 or 0xFF

		test	bl, al							; ZF = (前景色 & プレーン);
		setz	dl								; AL = ZF ? 0x01 : 0x00
		dec		dl								; AL--; // 0x00 or 0xFF

		;---------------------------------------
		; 16ドットフォントのコピー
		;---------------------------------------
		cld										; DF  = 0; // アドレス加算

		mov		ecx, 16							; ECX = 16; // 16ドット
.10L:											; do
												; {
		;---------------------------------------
		; フォントマスクの作成
		;---------------------------------------
		lodsb									;   AL  = *ESI++; //  フォント
		mov		ah, al							;   AH ~= AL;     // !フォント（ビット反転）
		not		ah								;   

		;---------------------------------------
		; 前景色
		;---------------------------------------
		and		al, dl							;   AL = 前景色 & フォント;

		;---------------------------------------
		; 背景色
		;---------------------------------------
		test	ebx, 0x0010						;   if (透過モード)
		jz		.11F							;   {
		and		ah, [edi]						;     AH = !フォント & [EDI] // 現在値
		jmp		.11E							;   }
.11F:											;   else
												;   {
		and		ah, dh							;     AH = !フォント & 背景色;
.11E:											;   }

		;---------------------------------------
		; 前景色と背景色を合成
		;---------------------------------------
		or		al, ah							;   AL  = 背景 | 前景;

		;---------------------------------------
		; 新しい値を出力
		;---------------------------------------
		mov		[edi], al						;   [EDI] = AL; // プレーンに書き込む

		add		edi, 80							;   EDI += 80;
		loop	.10L							; } while (--ECX);
.10E:											; 

		;---------------------------------------
		; 【レジスタの復帰】
		;---------------------------------------
		pop		edi
		pop		esi
		pop		edx
		pop		ecx
		pop		ebx
		pop		eax

		;---------------------------------------
		; 【スタックフレームの破棄】
		;---------------------------------------
		mov		esp, ebp
		pop		ebp

		ret

;************************************************************************
;	ビットパターンの書き込み
;========================================================================
;■書式		: void vram_bit_copy(bit, vram, flag);
;
;■引数
;	bit		: 出力ビットパターン
;	vram	: VRAMアドレス
;	flag	: 1:セット, 0:クリア
;
;■戻り値	: 無し
;************************************************************************
vram_bit_copy:
		;---------------------------------------
		; 【スタックフレームの構築】
		;---------------------------------------
												; EBP+20| 色（背景/前景色）
												; EBP+16| プレーン（ビット指定）
												; EBP+12| VRAMアドレス
												; EBP+ 8| 出力ビットパターン
												; ------+----------------
		push	ebp								; EBP+ 4| EIP（戻り番地）
		mov		ebp, esp						; EBP+ 0| EBP（元の値）
												; ------+----------------

		;---------------------------------------
		; 【レジスタの保存】
		;---------------------------------------
		push	eax
		push	ebx
		push	edi

		;---------------------------------------
		; 【処理の開始】
		;---------------------------------------
		mov		edi, [ebp +12]					; EDI = VRAMアドレス;
		movzx	eax, byte [ebp +16]				; EAX = プレーン（ビット指定）;
		movzx	ebx, word [ebp +20]				; EBX = 表示色;

		test	bl, al							; ZF = (前景色 & プレーン);
		setz	bl								; BL = ZF ? 0x01 : 0x00
		dec		bl								; BL--; // 0x00 or 0xFF

		;---------------------------------------
		; マスクデータの作成
		;---------------------------------------
		mov		al, [ebp + 8]					; AL = 出力ビットパターン;
		mov		ah, al							; AH ~= AL;     // !出力ビットパターン（ビット反転）
		not		ah								; 

		;---------------------------------------
		; 現在値の出力を取得
		;---------------------------------------
		and		ah, [edi]						; AH  = 現在値 & !出力ビットパターン
		and		al, bl							; AL  = 表示色 &  出力ビットパターン
		or		al, ah							; AL |= AH;

		;---------------------------------------
		; 新しい値を出力
		;---------------------------------------
		mov		[edi], al						; [EDI] = BL; // プレーンに書き込む

		;---------------------------------------
		; 【レジスタの復帰】
		;---------------------------------------
		pop		edi
		pop		ebx
		pop		eax

		;---------------------------------------
		; 【スタックフレームの破棄】
		;---------------------------------------
		mov		esp, ebp
		pop		ebp

		ret

